---
title: "Trabajo Practico - Laboratorio de Datos"
author: "Morales Joaquin, Lasorsa Lautaro y Palazzo Tomas"
date: "14/10/2021"
output:
  html_document:
    df_print: paged
    toc: yes
  html_notebook:
    theme: lumen
    toc: yes
    toc_float: yes
subtitle: "Laboratorio de Datos"
---

```{r}
# Librerias
require(tidyverse)
require(geosphere)
require(rvest) # Cargamos el paquete
```


```{r}
# Llamamos a los DataSets

datos_2014 = read.csv('../TP_LaboDeDatos/Data/aterrizajes-y-despegues-registrados-por-eana-2014.csv', encoding = 'latin1', sep = ';')
datos_2015 = read.csv('../TP_LaboDeDatos/Data/aterrizajes-y-despegues-registrados-por-eana-2015.csv', encoding = 'latin1', sep = ';')
datos_2016 = read.csv('../TP_LaboDeDatos/Data/aterrizajes-y-despegues-registrados-por-eana-2016.csv', encoding = 'latin1', sep = ';')
datos_2017 = read.csv('../TP_LaboDeDatos/Data/aterrizajes-y-despegues-registrados-por-eana-2017.csv', encoding = 'latin1', sep = ';')
datos_2018 = read.csv('../TP_LaboDeDatos/Data/aterrizajes-y-despegues-registrados-por-eana-2018.csv', encoding = 'latin1', sep = ';')
datos_2019 = read.csv('../TP_LaboDeDatos/Data/aterrizajes-y-despegues-registrados-por-eana-2019.csv', encoding = 'latin1', sep = ';')
datos_2020 = read.csv('../TP_LaboDeDatos/Data/aterrizajes-y-despegues-registrados-por-eana-2020.csv', encoding = 'latin1', sep = ';')

# Concateno todos los datos
datos = rbind(datos_2014,datos_2015,datos_2016,datos_2017,datos_2018,datos_2019,datos_2020)
datos2= read.csv('../TP_LaboDeDatos/Data/202109-informe-ministerio.csv', encoding = 'latin1', sep = ';')
```

```{r}
# Utilizamos la tabla que se encuentra en 'https://en.wikipedia.org/wiki/List_of_airports_in_Argentina'
# para acceder a las variables de ciudad, provincia y coordenadas de cada aeropuerto 

aeropuertos_wiki = read_html('https://en.wikipedia.org/wiki/List_of_airports_in_Argentina')
elemento_tabla   = html_element(aeropuertos_wiki,'.wikitable')
aeropuertos      = html_table(elemento_tabla)


# Variables utiles
N = dim(datos)[1]
cant_aeropuertos = dim(aeropuertos)[1]

```

```{r}
# Corrijo la columna de coordenadas 

separar     = strsplit((aeropuertos$Coordinates), '/') # Divide a los strings en los lugares donde haya '/' 
coordenadas = sapply(separar, function(x) x[3])        # Me quedo solo con el 3er tipo de coordenada
coordenadas = gsub('[^0-9,.,-]','', coordenadas)           # Elimino los caracteres que no quiero utilizar

aeropuertos = aeropuertos %>% 
  mutate(lat = as.numeric(substr(coordenadas, 1, 9)), long = as.numeric(substr(coordenadas, 10, 18))) # Separo a mano latitud y longitud (revizar si esta todo en orden)

aeropuertos = filter(aeropuertos, nchar(ICAO)>1)
aeropuertos = aeropuertos[order(aeropuertos$ICAO),]
```

```{r}
#Por ahora esta parte no sirve pero está bueno tenerla
# Agregando Ciudades
N2 = length(datos2$Hora.UTC)
datos2$ciudad_origen     = rep(NA, length(N2))
datos2$ciudad_destino    = rep(NA, length(N2))
datos2$provincia_origen  = rep(NA, length(N2))
datos2$provincia_destino = rep(NA, length(N2))
datos2$lat_origen        = rep(NA, length(N2)) 
datos2$long_origen       = rep(NA, length(N2)) 
datos2$lat_destino       = rep(NA, length(N2)) 
datos2$long_destino      = rep(NA, length(N2)) 
# datos %>% mutate(ciudad_origen = ) # Aca queria hacer exactamente lo de arriba pero usando dplyr



# El algoritmo de abajo ndar anda, tarda un monton. Hay que agregar el resto de las variables

for(i in 1:length(aeropuertos$ICAO)){
  inds = datos2$Aeropuerto==aeropuertos$IATA[i]
  datos2[inds,c('ciudad_origen','provincia_origen','lat_origen','long_origen')] = aeropuertos[i,c("City served","Province","lat","long")]
  
  inds = datos2$Origen...Destino==aeropuertos$IATA[i]
  datos2[inds,c('ciudad_destino','provincia_destino','lat_destino','long_destino')] = aeropuertos[i,c("City served","Province","lat","long")]
  
  
}
datos2 = drop_na(datos2)
datos2$distancia = distHaversine(datos2[,c("long_origen","lat_origen")],datos2[,c("long_destino","lat_destino")])
unique(datos2$Origen...Destino)
```
Una pregunta que nos pareció interesante es ver qué pares de aeropuertos se comunican más. 
```{r}
library(ggplot2)
aersA = unique(datos2$Aeropuerto)
aersB = unique(datos2$Origen...Destino)
mat = matrix(nrow = length(aersA), ncol = length(aersB))
row.names(mat) = aersA
colnames(mat) = aersB
for(i in 1:length(aersA)){
  for(j in 1:length(aersB)){
    mat[i,j]  =  sum((datos2$Aeropuerto==aersA[i]) & (datos2$Origen...Destino==aersB[j]))
  }
}
#heatmap(mat,Colv = NA, Rowv = NA, scale="column")
library(heatmaply)
help("heatmaply")
heatmaply(mat,cellnote=mat, Rowv = NA, Colv = NA, col_dend_up=TRUE, ylab="Aeropuerto", xlab="Origen/Destino")%>% 
  layout(xaxis = list(side = "top"))
```

```{r}
#Por ahora esta parte no sirve pero está bueno tenerla
# Agregando Ciudades

datos$ciudad_origen     = rep(NA, length(N))
datos$ciudad_destino    = rep(NA, length(N))
datos$provincia_origen  = rep(NA, length(N))
datos$provincia_destino = rep(NA, length(N))
datos$lat_origen        = rep(NA, length(N)) 
datos$long_origen       = rep(NA, length(N)) 
datos$lat_destino       = rep(NA, length(N)) 
datos$long_destino      = rep(NA, length(N)) 
# datos %>% mutate(ciudad_origen = ) # Aca queria hacer exactamente lo de arriba pero usando dplyr



# El algoritmo de abajo ndar anda, tarda un monton. Hay que agregar el resto de las variables

for(i in 1:length(aeropuertos$ICAO)){
  inds = datos$Origen.OACI==aeropuertos$ICAO[i]
  datos[inds,c('ciudad_origen','provincia_origen','lat_origen','long_origen')] = aeropuertos[i,c("City served","Province","lat","long")]
  
  inds = datos$Origen.OACI==aeropuertos$ICAO[i]
  datos[inds,c('ciudad_destino','provincia_destino','lat_destino','long_destino')] = aeropuertos[i,c("City served","Province","lat","long")]
  
  
}
datos = drop_na(datos)
datos$distancia = distHaversine(datos[,c("long_origen","lat_origen")],datos[,c("long_destino","lat_destino")])
```




